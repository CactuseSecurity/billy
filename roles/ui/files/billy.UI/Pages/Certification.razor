@using System
@using System.Threading
@using System.Text.RegularExpressions
@using billy.Ui.Data
@using billy.Report
@using billy.Report.Filter
@using billy.Ui.Pages.Reporting.Reports
@using billy.Api.Data
@using billy.Middleware.Client

@page "/certification"
@attribute [Authorize(Roles = "admin, recertifier, auditor")]

@inject ApiConnection apiConnection
@inject UserConfig userConfig
@inject MiddlewareClient middlewareClient

@* ==== LEFT SIDEBAR ==== *@
<Sidebar @ref="deviceSelectionSidebar" Collapsible="true" Resizeable="true" PositionLeft="true" @bind-Width="sidebarLeftWidth">
    <br>
    <div class="btn-group sticky-marker pl-3 pr-3 w-100">
        @if (processing == false)
        {
            <button type="button" class="btn btn-sm btn-primary" @onclick="() => GenerateRecertificationReport()">@(userConfig.GetText("load_rules"))</button>
        }
        else
        {
            <button type="button" class="btn btn-sm btn-danger" @onclick="() => CancelGeneration()">@(userConfig.GetText("stop_fetching"))</button>
        }
        <br>
    </div>
    <div class="p-3">
        <h5 class="text-left">@(userConfig.GetText("due_within")):</h5>
        <input  type="text" class="form-control form-control-sm" @bind="recertLookAheadDays" />
    </div>

    <AuthorizeView Roles="admin, auditor">
        <Authorized>
            <div class="p-3">
                <h7 class="text-left">@(userConfig.GetText("owner"))</h7>
                <Dropdown ElementType="FwoOwner" ElementToString="@(o => o.Name)" Nullable="true"
                    @bind-SelectedElement="selectedOwner" Elements="ownerList">
                    <ElementTemplate Context="owner">
                        @owner.Name
                    </ElementTemplate>
                </Dropdown>
            </div>
        </Authorized>
        <NotAuthorized>
            @if(collectedOwnerships.Count > 1)
            {
                <h7 class="text-left">@(userConfig.GetText("owner"))</h7>
                <Dropdown ElementType="FwoOwner" ElementToString="@(o => o.Name)" Nullable="true"
                    @bind-SelectedElement="selectedOwner" Elements="collectedOwnerships">
                    <ElementTemplate Context="owner">
                        @owner.Name
                    </ElementTemplate>
                </Dropdown>
            }
        </NotAuthorized>
    </AuthorizeView>

    <DeviceSelection Environment="Cert" @bind-DeviceFilter="deviceFilter" @bind-CollapseAll="collapseDevices" @bind-FilterInput="filterInput" @bind-SelectAll="selectAll" ></DeviceSelection>
</Sidebar>

@* ==== MAIN MIDDLE SECTION ==== *@

<div style="margin-left: @($"{sidebarLeftWidth + 10}px"); margin-right: @($"{sidebarRightWidth + 10}px");">
    <h3>@(userConfig.GetText("recertification"))</h3>
    <div class="btn-group sticky-marker-60">
        @if(!readonlyMode)
        {
            <AuthorizeView Roles="admin, recertifier">
                <Authorized>
                    @if(rulesFound)
                    {
                        <button type="button" class="btn btn-sm btn-danger" @onclick="() => RequestExecuteSelected()">@(userConfig.GetText("execute_selected"))</button>
                    }
                    else
                    {
                        <button type="button" class="btn btn-sm btn-danger" disabled>@(userConfig.GetText("execute_selected"))</button>
                    }
                </Authorized>
                <NotAuthorized>
                    <button type="button" class="btn btn-sm btn-danger" disabled>@(userConfig.GetText("execute_selected"))</button>
                </NotAuthorized>
            </AuthorizeView>
        }
    </div>
    <hr />
    <RulesReport Recertification="true" ReadonlyMode="readonlyMode" Managements="managements" RulesPerPage="rulesPerPage" 
        @bind-SelectedRules="selectedRules" SelectedReportType="ReportType.Recertification"/>
</div>

<PopUp Title="@(userConfig.GetText("add_comment"))" Show="@AddCommentMode" Large="true" OnClose="() => AddCommentMode = false">
    <Body>
        @if (AddCommentMode)
        {
            <form onsubmit="return false">
                <div class="form-group row">
                    <label for="comment" class="col-sm-2 col-form-label col-form-label-sm">@(userConfig.GetText("comment") + (userConfig.CommentRequired ? "*:" : ":"))</label>
                    <div class="col-sm-8">
                        <input id="comment" type="text" class="form-control form-control-sm" @bind="actComment" />
                    </div>
                </div>
            </form>
        }
    </Body>
    <Footer>
        <div class="btn-group">
            <button type="button" class="btn btn-sm btn-primary" @onclick="() => ExecuteSelected()">@(userConfig.GetText("ok"))</button>
            <button type="button" class="btn btn-sm btn-secondary" @onclick="Cancel">@(userConfig.GetText("cancel"))</button>
        </div>
    </Footer>
</PopUp>

@*==== RIGHT SIDEBAR ====*@
<RightSidebar @bind-Width="sidebarRightWidth" Tabset="rsbTabset" AnchorNavToRSB="anchorNavToRSB" CurrentReport="currentReport" @bind-SelectedRules="selectedRules"/>
<AnchorNavToRSB @ref="anchorNavToRSB" TabSet="rsbTabset" />

@code
{
    [CascadingParameter]
    Action<Exception?, string, string, bool> DisplayMessageInUi { get; set; } = DefaultInit.DoNothing;

    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }

    private billy.Ui.Shared.TabSet rsbTabset;
    private billy.Ui.Shared.AnchorNavToRSB anchorNavToRSB;

    private const int rulesPerPage = 0;

    private int sidebarLeftWidth = GlobalConfig.kSidebarLeftWidth;
    private int sidebarRightWidth = GlobalConfig.kSidebarRightWidth;
    private bool selectAll = true;

    private string filterInput = "remove=false and recertdisplay=30";
    private bool processing = false;
    private bool rulesFound = false;
    private CancellationTokenSource tokenSource = new CancellationTokenSource();

    private Management[] managements = new Management[0];
    
    private bool readonlyMode = false;
    public FwoOwner? selectedOwner = null;
    private List<FwoOwner> ownerList = new List<FwoOwner>();
    private List<FwoOwner> userOwnerships = new List<FwoOwner>();
    private List<FwoOwner> groupOwnerships = new List<FwoOwner>();
    private List<FwoOwner> collectedOwnerships = new List<FwoOwner>();
    private Dictionary<int, int> recertInterval = new Dictionary<int, int>();
    private DeviceFilter deviceFilter = new DeviceFilter();
    private List<Rule> selectedRules = new List<Rule>();
    private bool collapseDevices = false;

    private ReportBase? currentReport;
    private ReportTemplate reportParams = new ReportTemplate();

    private Sidebar? deviceSelectionSidebar;
    private bool AddCommentMode = false;
    private string actComment = "";
    private bool recertShowAnyMatch = true;
    private bool recertSingleLinePerRule = false;
    private int recertLookAheadDays = 0;

    private List<Rule> Certifications = new List<Rule>();
    private Dictionary<int, List<string>> deleteList = new Dictionary<int, List<string>>();

    private TicketCreator ticketCreator;

    protected override async Task OnInitializedAsync()
    {

        try
        {
            apiConnection.SetProperRole(authenticationStateTask!.Result.User, new List<string> { "recertifier", "admin", "auditor"});
            rulesFound = false;
            ticketCreator = new TicketCreator(apiConnection, userConfig);

            ownerList = await apiConnection.SendQueryAsync<List<FwoOwner>>(billy.Api.Client.Queries.OwnerQueries.getOwners);
            await CollectOwnerships();

            deviceFilter.Managements = await apiConnection.SendQueryAsync<List<ManagementSelect>>(DeviceQueries.getDevicesByManagements);
            await InvokeAsync(StateHasChanged);
            if (deviceFilter.NumberMgmtDev() > userConfig.MinCollapseAllDevices)
            {
                collapseDevices = true;
                await InvokeAsync(StateHasChanged);
            }
            recertLookAheadDays = Convert.ToInt32(userConfig.RecertificationDisplayPeriod);
        }
        catch (Exception exception)
        {
            DisplayMessageInUi(exception, userConfig.GetText("object_fetch"), "", true);
        }
    }

    private async Task CollectOwnerships()
    {
        userOwnerships = await apiConnection.SendQueryAsync<List<FwoOwner>>(OwnerQueries.getOwnerIdsForUser, new {userDn = userConfig.User.Dn});

        List<UserGroup> ownerGroups = await GroupAccess.GetGroupsFromInternalLdap(middlewareClient, userConfig, DisplayMessageInUi, true);
        List<string> ownerGrpDns = new List<string>();
        foreach(var grp in ownerGroups)
        {
            if(grp.Users.FirstOrDefault(x => x.Dn == userConfig.User.Dn) != null)
            {
                ownerGrpDns.Add(grp.Dn);
            }
        }
        if(ownerGrpDns.Count > 0)
        {
            groupOwnerships = await apiConnection.SendQueryAsync<List<FwoOwner>>(OwnerQueries.getOwnerIdsFromGroups, new {groupDns = ownerGrpDns});
        }

        foreach(var owner in userOwnerships)
        {
            collectedOwnerships.Add(owner);
            recertInterval.Add(owner.Id, owner.RecertInterval ?? userConfig.RecertificationPeriod);
        }
        foreach(var owner in groupOwnerships)
        {
            if(collectedOwnerships.FirstOrDefault(x => x.Id == owner.Id) == null)
            {
                collectedOwnerships.Add(owner);
                recertInterval.Add(owner.Id, owner.RecertInterval ?? userConfig.RecertificationPeriod);
            }
        }
        if(collectedOwnerships.Count == 1)
        {
            selectedOwner = collectedOwnerships[0];
        }
    }

    private async Task GenerateRecertificationReport()
    {
        processing = true;
        readonlyMode = !authenticationStateTask!.Result.User.IsInRole("recertifier") || selectedOwner == null;
        selectedRules.Clear();

        Management[] managementsOrig = managements;
        try
        {
            tokenSource = new CancellationTokenSource();
            var token = tokenSource.Token;

            if (!deviceFilter.isAnyDeviceFilterSet())  // display pop-up with warning
            {
                DisplayMessageInUi(null, userConfig.GetText("no_device_selected"), userConfig.GetText("E1001"), true);
                processing = false;
                return;
            }

            prepareReport();
            managements = new Management[0]; // reset management data when switching between reports

            try
            {
                if(currentReport != null)
                {
                    await currentReport.Generate(userConfig.ElementsPerFetch, apiConnection,
                    managementsReportIntermediate =>
                    {
                        managements = managementsReportIntermediate;
                        return InvokeAsync(StateHasChanged);
                    }, token);
                }
            }
            catch (OperationCanceledException e)
            {
                Log.WriteDebug("Generate Report", $"Cancelled: {e.Message}");
            }

            postProcessReport();
            processing = false;
            
            await InvokeAsync(StateHasChanged);
            if(!rulesFound)
            {
                DisplayMessageInUi(null, userConfig.GetText("generate_report"), userConfig.GetText("E4002"), true);
            }
        }
        catch (Exception exception)
        {
            processing = false;
            managements = managementsOrig;
            StateHasChanged();
            DisplayMessageInUi(exception, userConfig.GetText("generate_report"), "", true);
        }
    }

    private void CancelGeneration()
    {
        tokenSource.Cancel();
        DisplayMessageInUi(null, userConfig.GetText("report_data_fetch"), userConfig.GetText("E1003"), true);
    }

    private void prepareReport()
    {
        SyncFilterToDisplay();
        List<int> ownerList = new List<int>();
        if (selectedOwner != null)
        {
            ownerList.Add(selectedOwner.Id);
        }

        RecertFilter recertFilter = new RecertFilter()
        {
            RecertOwnerList = ownerList,
            RecertShowAnyMatch = recertShowAnyMatch,
            RecertSingleLinePerRule = recertSingleLinePerRule,
            RecertificationDisplayPeriod = recertLookAheadDays
        };
        reportParams = new ReportTemplate("", deviceFilter, (int) ReportType.Recertification, new TimeFilter(), recertFilter, null);
        currentReport = ReportBase.ConstructReport(reportParams, userConfig);
    }

    private void SyncFilterToDisplay()
    {
        filterInput = Regex.Replace(filterInput, "recertdisplay=" + @"-?\d+", $"recertdisplay={(userConfig.RecertificationPeriod-userConfig.RecertificationDisplayPeriod).ToString()}");
    }

    private void postProcessReport()
    {
        rulesFound = false;
        foreach (Management management in managements)
        {
            foreach (Device device in management.Devices)
            {
                if (device.ContainsRules())
                {
                    rulesFound = true;
                    foreach (Rule rule in device.Rules!)
                    {
                        rule.Metadata.UpdateRecertPeriods(userConfig.RecertificationPeriod, userConfig.RecertificationNoticePeriod);
                    }
                }
            }
        }
    }

    private void RequestExecuteSelected()
    {
        AddCommentMode = true;
    }

    private void Cancel()
    {
        AddCommentMode = false;
    }

    private async Task ExecuteSelected()
    {
        bool shortened = false;
        actComment = Sanitizer.SanitizeMand(actComment, ref shortened);
        if(shortened)
        {
            DisplayMessageInUi(null, userConfig.GetText("execute_selected"), userConfig.GetText("U0001"), true);
        }
        if(userConfig.CommentRequired && actComment == "")
        {
            DisplayMessageInUi(null, userConfig.GetText("execute_selected"), userConfig.GetText("E4001"), true);
            return;
        }
        AddCommentMode = false;
        try
        {
            AnalyzeSelected();
            await DoRecerts();

            // create delete tickets
            if(userConfig.RecAutoCreateDeleteTicket)
            {
                foreach(var device in deleteList)
                {
                    await ticketCreator.CreateDecertRuleDeleteTicket(device.Key, device.Value, actComment, DateTime.Now.AddDays(userConfig.RuleRemovalGracePeriod));
                }
            }

            // reload updated report
            await GenerateRecertificationReport();
        }
        catch (Exception exception)
        {
            DisplayMessageInUi(exception, userConfig.GetText("execute_selected"), "", true);
        }
    }

    private void AnalyzeSelected()
    {
        // collect selected recerts + decerts
        Certifications = new List<Rule>();

        foreach (Management management in managements)
        {
            foreach (Device device in management.Devices)
            {
                if(device.Rules != null)
                {
                    foreach (Rule rule in device.Rules)
                    {
                        if(rule.Metadata.Recert || rule.Metadata.ToBeRemoved)
                        {
                            rule.DeviceId = device.Id;
                            Certifications.Add(rule);
                        }
                    }
                }
            }
        }
    }

    private async Task DoRecerts()
    {
        int recerts = 0;
        int decerts = 0;
        deleteList = new Dictionary<int, List<string>>();

        if (Certifications.Count > 0)
        {
            foreach(var certRule in Certifications)
            {
                if(await Recertify(certRule))
                {
                    if(certRule.Metadata.Recert)
                    {
                        recerts++;
                    }
                    else
                    {
                        decerts++;
                        if(await checkAllDecertified(certRule))
                        {
                            if(!deleteList.ContainsKey(certRule.DeviceId))
                            {
                                deleteList.Add(certRule.DeviceId, new List<string>());
                            }
                            deleteList[certRule.DeviceId].Add(certRule.Uid ?? "");
                        }
                    }
                }
            }
        }
        string txt = userConfig.GetText("recerts_executed") + recerts.ToString() + ", " +
                        userConfig.GetText("decerts_executed") + decerts.ToString();
        DisplayMessageInUi(null, userConfig.GetText("execute_selected"), txt, false);
    }

    private async Task<bool> checkAllDecertified(Rule rule)
    {
        var variables = new
        {
            ruleId = rule.Id,
        };
        return ((await apiConnection.SendQueryAsync<List<Recertification>>(RecertQueries.getOpenRecertsForRule, variables)).Count == 0);
    }

    private async Task<bool> Recertify(Rule rule)
    {
        var variables = new
        {
            ruleId = rule.Id,
            ownerId = (selectedOwner ?? throw new Exception("Recertification without owner not allowed.")).Id,
            userDn = userConfig.User.Dn,
            recertified = rule.Metadata.Recert,
            recertDate = DateTime.Now,
            comment = actComment
        };
        bool recertOk = (await apiConnection.SendQueryAsync<ReturnId>(RecertQueries.recertify, variables)).AffectedRows > 0;
        if(recertOk && rule.Metadata.Recert)
        {
            await InitRecert(rule);
        }
        return recertOk;
    }

    private async Task InitRecert(Rule rule)
    {
        if (recertInterval != null && selectedOwner != null && recertInterval.ContainsKey(selectedOwner.Id))
        {
            var prepvariables = new
            {
                ruleMetadataId = rule.Metadata.Id,
                ruleId = rule.Id,
                ipMatch = rule.IpMatch != "" ? rule.IpMatch : null,
                ownerId = (selectedOwner ?? throw new Exception("Recertification without owner not allowed.")).Id,
                nextRecertDate = DateTime.Now.AddDays(recertInterval[selectedOwner.Id])
            };
            await apiConnection.SendQueryAsync<object>(RecertQueries.prepareNextRecertification, prepvariables);
        }
        else
        {
            DisplayMessageInUi(null, userConfig.GetText("execute_selected"), userConfig.GetText("missing_owner_id"), true);
        }
    }
}
